## Part 1a  
  1) values added: 20 is printed by line 9. This is printed since we can access the var result value throughout the entire function. We just update the variable accordingly and print it out.
  2) final result: 20 is printed by line 13. Again, this is printed since we can access the var result value throughout the entire function, we can have access to it even after the if statement block. Thus, we just update the variable accordingly and print it out.
  3) values added: 20 is printed by line 9. This is printed because the let result variable is declared within the if statement block and the print statement in line 9 is also within the same if statement block. So since they are in the same block, we can just update the variable accordingly and print it out. 
  4) The code will return an error because the let result variable is declared in the if statement block & line 13 is outside of the if statement block. And we know that when you declare a variable with the let keyword, that variable only has block scope so we won't be able to access result and print it.  
  5) The code will return an error because you aren't supposed to reassign the result value after it is set as 0 since it is of type const.   
  6) Again, the code will return an error because you aren't supposed to reassign the result value after it is set as 0 since it is of type const. Since we call sumValues(10,10, true), we will run the if statement which will attempt to change the value of result, but we can't do that since it is a const.  

## Part 1b 
  1) In line 12, we will print 3. Since i is a var, we know that we can access it throughout the entire function. So since we are printing at line 12 (which is within the discountPrices function definition), we will not get an error. We get the value 3 for i by simply going through the for loop and updating it accordingly & eventually printing the value of i at line 12. 
  2) In line 13, we will print 150. Again, since discountedPrice is of type var, we know that we can access it throughout the entire function. So since we are printing the value of discountedPrice at line 13 (which is within the discountPrices function definition), we will not get an error. We get the value 150 by continually updating the value of discountedPrice as we go through the for loop. And we end up with 150 because that is the last updated value of discountedPrice after we exit the for loop.
  3) In line 14, we will also print 150. Since finalPrice is of type var, we know that we can access it throughout the entire function (it is also not defined within a certain block, it's defined at the top of the function). So since we are printing the value of finalPrice at line 14 (which is within the discountPrices function definition), we will not get an error. We get the value 150 by continually updating the value of discountedPrice as we go through the for loop. And we end up with 150 because that is the last updated value of finalPrice after we exit the for loop.
  4) This function will return a new array called discounted with the updated discountedPrice values. It will return [50, 100, 150]. We return the discounted array which again is of type var, so we can access it throughout the entire function - which is why we don't get an error. And we end up with these values in the array because in the discountPrices function, we have a variable called discountedPrice that we continually update as we go through the for loop & push that value into the discounted array for each iteration of the for loop so that the array holds each of the discountedPrices.
  5) This will cause an error because the variable i is of type let and since we declare it within the for loop block, we will not be able to access it at line 12 when we want to print the value of i. 
  6)  Again, this will cause an error because the variable discountedPrice is of type let and since we declare it within the for loop block, we will not be able to access it at line 13 when want to print the value of discountedPrice.
  7)  At line 14, we will print the value 150. It will not cause an error because even though the finalPrice variable is of type let, it is not declared within a specific block of code in the function. finalPrice is declared at the top of the discountPrices function and is not within a block, so when we want to print the value of it at line 14, we can do so without error. We get the value 300.5 by simply going through the for loop and updating the variable accordingly. We end up with 150 because that is the last updated value of finalPrice after we exit the for loop.
  8) This function will still return a new array called discounted with the updated discountedPrice values. It will return [50,100,150]. Even though this array is of type let, it is again not declared within a specific block of code in the function. The discounted array is declared at the top of the discountPrices function is not declared within a block, so when we reference it at the end of the function to return it, we won't get an error. And we get all the correct values within this array since we push the updated values of the discountedPrice into the discounted array as we go through the for loop.
  9) At line 11, the code will cause an error. Because again, the variable i is of type let and since we declare it within the for loop block, we will not be able to access it at line 11 when we want to print the value of i. 
  10) At line 12, we will print the length of the prices array that was passed into the function. We print the value of 3. Even though the length variable is of type const, it was declared at the top of the function and not within any specific block. So that valuable will be reachable once we want to print it at line 12. 
  11) This function will still return the discounted array [50,100,150]. This is because for each iteration of the for loop, you are redeclaring the discountedPrice variable. So even though discountedPrice is of type, it gets redeclared each iteration so we are pushing the correctly updated values into the discounted array each iteration of the for loop.
  12) A) student.name;  
      B) student['Grad Year']  
      C) student.greeting()  
      D) student['Favorite Teacher'].name  
      E) student.courseLoad[1] (I interpreted first index as index 1 and not 0, but if the directions meant 0th index, then just change the 1 to a 0.)  
  13) A) The output is '32'. This is the output because JS sees this line as "string value plus number value." And since the sum operator is also used for concatenation, JS concatenates all the values as strings.  
      B) The output is 1. Even though we start with a string here, you cannot subtract strings, so it makes more sense for JS to parse everything as numbers because subtraction is an arithmetical operation. So we just do the arithmetic 3-2 =1.  
      C) The output is 3. Null is parsed as a number & it becomes 0. Which is why 3 + null (aka zero) is just 3.  
      D) The output is '3null'. Again JS sees this line as "string value plus null". And since the sum operator is also used for concatenation, JS concatenates all the values as strings & we just concatenate the two values to get '3null'.  
      E) The output is 4. True is parsed as the number 1, so we just do arithmetic and get true (aka 1) + 3 which is 4.   
      F) The output is 0. Both false and null get parsed to be the number 0. So we get false (aka 0) + null (aka 0) = 0.  
      G) The output is '3undefined'. Again JS sees this line as "string value plus undefined." And since the sum operator is also used for concatenation, JS concatenates all the values as strings & we just concatenate the two values to get '3undefined'.  
      H) The output is NaN. This makes sense because when undefined is parsed into a number, it is parsed as NaN. And again, you cannot subtract strings, so it makes more sense for JS to parse everything as numbers because subtraction is an arithmetical operation. Doing the arithmetic, we get 3 - NaN, which is just NaN.  
  14) A) The output is true. It computes the ASCII value of the string '2' which is definitely greater than the number 1. The ASCII value of string '2' is 50 and 50 > 1.  
      B) The output is false. Because of dictionary comparison '2' is actually greater than '12'. The first char '2' is greater than the first char '1'.  
      C) The output is true. == is a comparison operator which transforms the operands having the same type before comparison. So, when you compare a string with a number, Javascript converts any string to a number. So 2 is equivalent to 2.  
      D) The output is false. === is a strict equality comparison operator in Javascript which returns false for the values which are not of a similar type. So since we have a string and a number, the values are not of similar type so we return false.   
      E) The output is false. The value of true gets converted into a number since we use == operator, but the numerical value of true is 1 which is NOT equal to 2.  
      F) The output is true. We can see that the boolean value from Boolean(2) is being returned true because the variable passed into this method has a value and is not null. So since Boolean(2) returns true, we get the comparison true === true which is true since true is equivalent to true and they are of the same type.  
  15) The double equals (==) is a comparison operator which transforms the operands having the same type before comparison. For instance, when you compare a string with a number, JavaScript converts any string to a number. However, the triple equals (===) is a strict equality comparison operator in JavaScript which returns false for the values which are not of a similar type.   

  17) Nothing is printed as a result of this code since we have no print statements, but the array that is returned as a result of running modifyArray([1,2,3], doSomething) is [2,4,6]. In the modifyArray method, we initially create an empty array that will be populated with the updated values of [1,2,3] at the end of the method. Now in the for loop, we are going through each of the elements in the passed in array [1,2,3] and multiplying each value by 2 since we do callback(array[i]) in which callback is the doSomething(num) method which returns 2 * num. After multiplying an element in the array, [1,2,3], by 2 we push that into the newArr we created at the beginning. So after doing this for each of the elements in the array, [1,2,3], we will end up with the values of newArr being [2,4,6]. And this is why the array that is returned from modifyArray([1,2,3], doSomething) is [2,4,6].
  19) The output of the above code is 1 4 3 2 (each number on a new line). 
  
